// this file is generated via daScript automatic C++ binder
// all user modifications will be lost after this file is re-generated

template <> struct cast_arg<bgfx_dynamic_index_buffer_handle_s> {
	static __forceinline bgfx_dynamic_index_buffer_handle_s to ( Context & ctx, SimNode * node ) {
		vec4f res = node->eval(ctx);
		return * cast<bgfx_dynamic_index_buffer_handle_s *>::to(res);
	}
};
template <> struct cast_arg<bgfx_dynamic_vertex_buffer_handle_s> {
	static __forceinline bgfx_dynamic_vertex_buffer_handle_s to ( Context & ctx, SimNode * node ) {
		vec4f res = node->eval(ctx);
		return * cast<bgfx_dynamic_vertex_buffer_handle_s *>::to(res);
	}
};
template <> struct cast_arg<bgfx_frame_buffer_handle_s> {
	static __forceinline bgfx_frame_buffer_handle_s to ( Context & ctx, SimNode * node ) {
		vec4f res = node->eval(ctx);
		return * cast<bgfx_frame_buffer_handle_s *>::to(res);
	}
};
template <> struct cast_arg<bgfx_index_buffer_handle_s> {
	static __forceinline bgfx_index_buffer_handle_s to ( Context & ctx, SimNode * node ) {
		vec4f res = node->eval(ctx);
		return * cast<bgfx_index_buffer_handle_s *>::to(res);
	}
};
template <> struct cast_arg<bgfx_indirect_buffer_handle_s> {
	static __forceinline bgfx_indirect_buffer_handle_s to ( Context & ctx, SimNode * node ) {
		vec4f res = node->eval(ctx);
		return * cast<bgfx_indirect_buffer_handle_s *>::to(res);
	}
};
template <> struct cast_arg<bgfx_occlusion_query_handle_s> {
	static __forceinline bgfx_occlusion_query_handle_s to ( Context & ctx, SimNode * node ) {
		vec4f res = node->eval(ctx);
		return * cast<bgfx_occlusion_query_handle_s *>::to(res);
	}
};
template <> struct cast_arg<bgfx_program_handle_s> {
	static __forceinline bgfx_program_handle_s to ( Context & ctx, SimNode * node ) {
		vec4f res = node->eval(ctx);
		return * cast<bgfx_program_handle_s *>::to(res);
	}
};
template <> struct cast_arg<bgfx_shader_handle_s> {
	static __forceinline bgfx_shader_handle_s to ( Context & ctx, SimNode * node ) {
		vec4f res = node->eval(ctx);
		return * cast<bgfx_shader_handle_s *>::to(res);
	}
};
template <> struct cast_arg<bgfx_texture_handle_s> {
	static __forceinline bgfx_texture_handle_s to ( Context & ctx, SimNode * node ) {
		vec4f res = node->eval(ctx);
		return * cast<bgfx_texture_handle_s *>::to(res);
	}
};
template <> struct cast_arg<bgfx_uniform_handle_s> {
	static __forceinline bgfx_uniform_handle_s to ( Context & ctx, SimNode * node ) {
		vec4f res = node->eval(ctx);
		return * cast<bgfx_uniform_handle_s *>::to(res);
	}
};
template <> struct cast_arg<bgfx_vertex_buffer_handle_s> {
	static __forceinline bgfx_vertex_buffer_handle_s to ( Context & ctx, SimNode * node ) {
		vec4f res = node->eval(ctx);
		return * cast<bgfx_vertex_buffer_handle_s *>::to(res);
	}
};
template <> struct cast_arg<bgfx_vertex_layout_handle_s> {
	static __forceinline bgfx_vertex_layout_handle_s to ( Context & ctx, SimNode * node ) {
		vec4f res = node->eval(ctx);
		return * cast<bgfx_vertex_layout_handle_s *>::to(res);
	}
};
template <> struct cast_arg<bgfx_caps_gpu_s> {
	static __forceinline bgfx_caps_gpu_s to ( Context & ctx, SimNode * node ) {
		vec4f res = node->eval(ctx);
		return * cast<bgfx_caps_gpu_s *>::to(res);
	}
};
template <> struct cast_arg<bgfx_caps_limits_s> {
	static __forceinline bgfx_caps_limits_s to ( Context & ctx, SimNode * node ) {
		vec4f res = node->eval(ctx);
		return * cast<bgfx_caps_limits_s *>::to(res);
	}
};
template <> struct cast_arg<bgfx_caps_s> {
	static __forceinline bgfx_caps_s to ( Context & ctx, SimNode * node ) {
		vec4f res = node->eval(ctx);
		return * cast<bgfx_caps_s *>::to(res);
	}
};
template <> struct cast_arg<bgfx_internal_data_s> {
	static __forceinline bgfx_internal_data_s to ( Context & ctx, SimNode * node ) {
		vec4f res = node->eval(ctx);
		return * cast<bgfx_internal_data_s *>::to(res);
	}
};
template <> struct cast_arg<bgfx_platform_data_s> {
	static __forceinline bgfx_platform_data_s to ( Context & ctx, SimNode * node ) {
		vec4f res = node->eval(ctx);
		return * cast<bgfx_platform_data_s *>::to(res);
	}
};
template <> struct cast_arg<bgfx_resolution_s> {
	static __forceinline bgfx_resolution_s to ( Context & ctx, SimNode * node ) {
		vec4f res = node->eval(ctx);
		return * cast<bgfx_resolution_s *>::to(res);
	}
};
template <> struct cast_arg<bgfx_init_limits_s> {
	static __forceinline bgfx_init_limits_s to ( Context & ctx, SimNode * node ) {
		vec4f res = node->eval(ctx);
		return * cast<bgfx_init_limits_s *>::to(res);
	}
};
template <> struct cast_arg<bgfx_init_s> {
	static __forceinline bgfx_init_s to ( Context & ctx, SimNode * node ) {
		vec4f res = node->eval(ctx);
		return * cast<bgfx_init_s *>::to(res);
	}
};
template <> struct cast_arg<bgfx_memory_s> {
	static __forceinline bgfx_memory_s to ( Context & ctx, SimNode * node ) {
		vec4f res = node->eval(ctx);
		return * cast<bgfx_memory_s *>::to(res);
	}
};
template <> struct cast_arg<bgfx_transient_index_buffer_s> {
	static __forceinline bgfx_transient_index_buffer_s to ( Context & ctx, SimNode * node ) {
		vec4f res = node->eval(ctx);
		return * cast<bgfx_transient_index_buffer_s *>::to(res);
	}
};
template <> struct cast_arg<bgfx_transient_vertex_buffer_s> {
	static __forceinline bgfx_transient_vertex_buffer_s to ( Context & ctx, SimNode * node ) {
		vec4f res = node->eval(ctx);
		return * cast<bgfx_transient_vertex_buffer_s *>::to(res);
	}
};
template <> struct cast_arg<bgfx_instance_data_buffer_s> {
	static __forceinline bgfx_instance_data_buffer_s to ( Context & ctx, SimNode * node ) {
		vec4f res = node->eval(ctx);
		return * cast<bgfx_instance_data_buffer_s *>::to(res);
	}
};
template <> struct cast_arg<bgfx_texture_info_s> {
	static __forceinline bgfx_texture_info_s to ( Context & ctx, SimNode * node ) {
		vec4f res = node->eval(ctx);
		return * cast<bgfx_texture_info_s *>::to(res);
	}
};
template <> struct cast_arg<bgfx_uniform_info_s> {
	static __forceinline bgfx_uniform_info_s to ( Context & ctx, SimNode * node ) {
		vec4f res = node->eval(ctx);
		return * cast<bgfx_uniform_info_s *>::to(res);
	}
};
template <> struct cast_arg<bgfx_attachment_s> {
	static __forceinline bgfx_attachment_s to ( Context & ctx, SimNode * node ) {
		vec4f res = node->eval(ctx);
		return * cast<bgfx_attachment_s *>::to(res);
	}
};
template <> struct cast_arg<bgfx_transform_s> {
	static __forceinline bgfx_transform_s to ( Context & ctx, SimNode * node ) {
		vec4f res = node->eval(ctx);
		return * cast<bgfx_transform_s *>::to(res);
	}
};
template <> struct cast_arg<bgfx_view_stats_s> {
	static __forceinline bgfx_view_stats_s to ( Context & ctx, SimNode * node ) {
		vec4f res = node->eval(ctx);
		return * cast<bgfx_view_stats_s *>::to(res);
	}
};
template <> struct cast_arg<bgfx_encoder_stats_s> {
	static __forceinline bgfx_encoder_stats_s to ( Context & ctx, SimNode * node ) {
		vec4f res = node->eval(ctx);
		return * cast<bgfx_encoder_stats_s *>::to(res);
	}
};
template <> struct cast_arg<bgfx_stats_s> {
	static __forceinline bgfx_stats_s to ( Context & ctx, SimNode * node ) {
		vec4f res = node->eval(ctx);
		return * cast<bgfx_stats_s *>::to(res);
	}
};
template <> struct cast_arg<bgfx_vertex_layout_s> {
	static __forceinline bgfx_vertex_layout_s to ( Context & ctx, SimNode * node ) {
		vec4f res = node->eval(ctx);
		return * cast<bgfx_vertex_layout_s *>::to(res);
	}
};
